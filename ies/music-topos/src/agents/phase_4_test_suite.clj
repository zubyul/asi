(ns agents.phase-4-test-suite
  \"Phase 4 Test Suite: Comprehensive Validation of Multi-Agent Training

  Tests:
  1. Individual agent creation and initialization
  2. Pattern recognition accuracy
  3. Pattern generation and diversity
  4. Anomaly detection sensitivity
  5. Multi-agent training convergence
  6. Population agreement and entropy
  7. Complete Phase 3→4 pipeline

  Status: 2025-12-21 - Test framework ready\"
  (:require [agents.phase-4-agent-learning :as phase4]\n            [agents.phase-4-integration :as phase4-int]\n            [clojure.math :as math]\n            [clojure.string :as str]))\n\n;; =============================================================================\n;; Section 1: Mock Data Generation\n;; =============================================================================\n\n(defn generate-mock-phase3-result\n  \"Generate realistic mock Phase 3 result for testing\"\n  []\n\n  (let [;; Create mock patterns with 5 dimensions\n        patterns (vec (for [i (range 100)]\n                      {:pattern-vector [(rand) (rand) (rand) (rand) (rand)]\n                       :leitmotif (rand-nth [:technical-innovation :collaborative-work\n                                            :philosophical-reflection :network-building\n                                            :musical-creation :synthesis])\n                       :id i}))\n\n        ;; Create mock clusters\n        cluster-map {0 (take 30 patterns)\n                     1 (take 35 (drop 30 patterns))\n                     2 (take 35 (drop 65 patterns))}\n\n        ;; Create mock archetypes\n        archetypes {\"Archetype-0\" {:size 30\n                                   :cluster-id 0\n                                   :dominant-leitmotif :technical-innovation\n                                   :dimension-means {:topic 0.85 :mode 0.70 :temporal 0.55 :network 0.60 :length 0.45}}\n                    \"Archetype-1\" {:size 35\n                                   :cluster-id 1\n                                   :dominant-leitmotif :collaborative-work\n                                   :dimension-means {:topic 0.75 :mode 0.80 :temporal 0.65 :network 0.70 :length 0.55}}\n                    \"Archetype-2\" {:size 35\n                                   :cluster-id 2\n                                   :dominant-leitmotif :musical-creation\n                                   :dimension-means {:topic 0.90 :mode 0.75 :temporal 0.60 :network 0.50 :length 0.70}}}]\n\n    {:phase \"3\"\n     :status :complete\n     :archetypes archetypes\n     :all-data {:patterns patterns\n               :full-cluster-map cluster-map\n               :all-anomalies []\n               :phase-2-result {}}}))\n\n;; =============================================================================\n;; Section 2: Individual Component Tests\n;; =============================================================================\n\n(defn test-agent-creation\n  \"Test 1: Verify agent creation works correctly\"\n  []\n\n  (println \"\\n━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━\")\n  (println \"TEST 1: Agent Creation and Initialization\")\n  (println \"━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━\")\n\n  (let [training-data (vec (for [i (range 10)]\n                           {:pattern-vector [(rand) (rand) (rand) (rand) (rand)]\n                            :leitmotif :technical-innovation\n                            :id i}))\n        agent (phase4/create-agent \"agent-0\" training-data)]\n\n    (println (str \"✅ Agent created: \" (:id agent)))\n    (println (str \"   Training examples: \" (count (:pattern-memory agent))))\n    (println (str \"   Initial accuracy: \" (:recognition-accuracy agent)))\n\n    ;; Validate agent structure\n    (assert (= \"agent-0\" (:id agent)) \"Agent ID should match\")\n    (assert (= 10 (count (:pattern-memory agent))) \"Should have all training examples\")\n    (assert (= 0.0 (:recognition-accuracy agent)) \"Initial accuracy should be 0.0\")\n    (assert (vector? (:generated-patterns agent)) \"Should have generated-patterns vector\")\n    (assert (map? (:dimensions {:topic 0.5 :mode 0.5 :temporal 0.5 :network 0.5 :length 0.5})) \"Should support dimension map\")\n\n    (println \"✅ Agent creation test PASSED\")\n    true))\n\n(defn test-pattern-recognition\n  \"Test 2: Verify pattern recognition converges\"\n  []\n\n  (println \"\\n━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━\")\n  (println \"TEST 2: Pattern Recognition Convergence\")\n  (println \"━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━\")\n\n  ;; Create distinct pattern clusters\n  (let [;; Cluster 1: high topic, low others\n        cluster1 (vec (for [i (range 15)]\n                      {:pattern-vector [0.9 0.2 0.3 0.2 0.3]\n                                      :leitmotif :technical-innovation\n                                      :id i}))\n\n        ;; Cluster 2: low topic, high mode\n        cluster2 (vec (for [i (range 15 30)]\n                      {:pattern-vector [0.1 0.9 0.7 0.8 0.4]\n                                      :leitmotif :collaborative-work\n                                      :id i}))\n\n        agent (phase4/create-agent \"agent-test\" (concat cluster1 cluster2))\n        trained (phase4/train-agent-on-examples agent)]\n\n    (println (str \"✅ Agent trained on \" (count (:pattern-memory agent)) \" patterns\"))\n    (println (str \"   Recognition accuracy: \" (format \"%.1f%%\" (* 100 (:recognition-accuracy trained)))))\n\n    ;; Validate training improved accuracy\n    (assert (> (:recognition-accuracy trained) 0.5) \"Accuracy should be > 50% with distinct clusters\")\n    (assert (> (:correct-predictions trained) 0) \"Should have correct predictions\")\n\n    (println \"✅ Pattern recognition test PASSED\")\n    true))\n\n(defn test-pattern-generation\n  \"Test 3: Verify pattern generation works\"\n  []\n\n  (println \"\\n━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━\")\n  (println \"TEST 3: Pattern Generation and Diversity\")\n  (println \"━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━\")\n\n  (let [training-data (vec (for [i (range 10)]\n                           {:pattern-vector [(+ 0.4 (rand 0.2))\n                                            (+ 0.4 (rand 0.2))\n                                            (+ 0.4 (rand 0.2))\n                                            (+ 0.4 (rand 0.2))\n                                            (+ 0.4 (rand 0.2))]\n                            :leitmotif :musical-creation\n                            :id i}))\n        agent (phase4/create-agent \"agent-gen\" training-data)\n        with-generation (phase4/generate-patterns-and-track-entropy agent 5)]\n\n    (println (str \"✅ Patterns generated\"))\n    (println (str \"   Generated patterns: \" (count (:generated-patterns with-generation))))\n    (println (str \"   Generation entropy: \" (format \"%.2f\" (:generation-entropy with-generation))))\n\n    ;; Validate generation\n    (assert (> (count (:generated-patterns with-generation)) 0) \"Should generate patterns\")\n    (assert (>= (:generation-entropy with-generation) 0.0) \"Entropy should be non-negative\")\n\n    (println \"✅ Pattern generation test PASSED\")\n    true))\n\n(defn test-anomaly-detection\n  \"Test 4: Verify anomaly detection works\"\n  []\n\n  (println \"\\n━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━\")\n  (println \"TEST 4: Anomaly Detection in Agent Space\")\n  (println \"━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━\")\n\n  (let [;; Normal patterns centered at [0.5, 0.5, ...]\n        normal-patterns (vec (for [i (range 20)]\n                             {:pattern-vector [(+ 0.5 (rand 0.1))\n                                              (+ 0.5 (rand 0.1))\n                                              (+ 0.5 (rand 0.1))\n                                              (+ 0.5 (rand 0.1))\n                                              (+ 0.5 (rand 0.1))]\n                              :leitmotif :synthesis\n                              :id i}))\n        ;; Outlier patterns\n        outlier-patterns [{:pattern-vector [0.0 0.0 0.0 0.0 0.0] :leitmotif :synthesis :id 100}\n                         {:pattern-vector [1.0 1.0 1.0 1.0 1.0] :leitmotif :synthesis :id 101}]\n        agent (phase4/create-agent \"agent-anom\" (concat normal-patterns outlier-patterns))\n        with-anomalies (phase4/detect-anomalies-in-agent-space agent (:generated-patterns agent))]\n\n    (println (str \"✅ Anomalies detected\"))\n    (println (str \"   Detected anomalies: \" (:anomaly-count with-anomalies)))\n\n    ;; Validate anomaly detection\n    (assert (>= (:anomaly-count with-anomalies) 0) \"Anomaly count should be non-negative\")\n\n    (println \"✅ Anomaly detection test PASSED\")\n    true))\n\n(defn test-agent-training-loop\n  \"Test 5: Verify multi-agent training loop convergence\"\n  []\n\n  (println \"\\n━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━\")\n  (println \"TEST 5: Multi-Agent Training Convergence\")\n  (println \"━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━\")\n\n  (let [phase3 (generate-mock-phase3-result)\n        training-data (reduce (fn [acc [archetype-name archetype]]\n                               (let [cluster-id (:cluster-id archetype)\n                                     cluster-patterns (get (get-in phase3 [:all-data :full-cluster-map]) cluster-id)]\n                                 (assoc acc archetype-name\n                                   {:patterns cluster-patterns\n                                    :leitmotif (:dominant-leitmotif archetype)})))\n                             {}\n                             (get-in phase3 [:archetypes]))\n        topology (phase4/initialize-9-agent-topology training-data)\n        trained-topology (phase4/train-agent-population topology 3)]  ; 3 generations for quick test\n\n    (println (str \"✅ Training complete\"))\n    (println (str \"   Agents trained: \" (count (:trained-agents trained-topology))))\n\n    ;; Validate topology\n    (assert (= 9 (count (:trained-agents trained-topology))) \"Should train 9 agents\")\n    (doseq [agent (:trained-agents trained-topology)]\n      (assert (>= (:recognition-accuracy agent) 0.0) \"Accuracy should be non-negative\"))\n\n    (println \"✅ Multi-agent training test PASSED\")\n    true))\n\n(defn test-population-metrics\n  \"Test 6: Verify population metrics calculation\"\n  []\n\n  (println \"\\n━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━\")\n  (println \"TEST 6: Population Metrics and Agreement\")\n  (println \"━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━\")\n\n  (let [phase3 (generate-mock-phase3-result)\n        training-data (reduce (fn [acc [archetype-name archetype]]\n                               (let [cluster-id (:cluster-id archetype)\n                                     cluster-patterns (get (get-in phase3 [:all-data :full-cluster-map]) cluster-id)]\n                                 (assoc acc archetype-name\n                                   {:patterns cluster-patterns\n                                    :leitmotif (:dominant-leitmotif archetype)})))\n                             {}\n                             (get-in phase3 [:archetypes]))\n        topology (phase4/initialize-9-agent-topology training-data)\n        trained-topology (phase4/train-agent-population topology 2)\n        trained-agents (:trained-agents trained-topology)\n        pop-entropy (phase4/calculate-population-entropy trained-agents)\n        test-patterns (take 5 (get-in phase3 [:all-data :patterns]))\n        pop-agreement (phase4/calculate-population-agreement trained-agents test-patterns)]\n\n    (println (str \"✅ Population metrics calculated\"))\n    (println (str \"   Population entropy: \" (format \"%.3f\" pop-entropy)))\n    (println (str \"   Population agreement: \" (format \"%.1f%%\" (* 100 pop-agreement))))\n\n    ;; Validate metrics\n    (assert (>= pop-entropy 0.0) \"Entropy should be non-negative\")\n    (assert (and (>= pop-agreement 0.0) (<= pop-agreement 1.0)) \"Agreement should be in [0, 1]\")\n\n    (println \"✅ Population metrics test PASSED\")\n    true))\n\n;; =============================================================================\n;; Section 3: Integration Tests\n;; =============================================================================\n\n(defn test-complete-phase4-pipeline\n  \"Test 7: Complete Phase 3→4 pipeline\"\n  []\n\n  (println \"\\n━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━\")\n  (println \"TEST 7: Complete Phase 3→4 Pipeline\")\n  (println \"━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━\")\n\n  (let [phase3-result (generate-mock-phase3-result)\n        ;; Run complete Phase 4 pipeline\n        phase4-result (phase4-int/run-full-phase-4 phase3-result 2)]\n\n    (println (str \"✅ Phase 4 pipeline complete\"))\n\n    ;; Validate Phase 4 result structure\n    (assert (= \"4\" (:phase phase4-result)) \"Should be Phase 4\")\n    (assert (= :complete (:status phase4-result)) \"Should have complete status\")\n    (assert (contains? phase4-result :agent-topology) \"Should have agent topology\")\n    (assert (contains? phase4-result :trained-agents) \"Should have trained agents\")\n    (assert (contains? phase4-result :population-metrics) \"Should have population metrics\")\n\n    (println \"✅ Complete Phase 3→4 pipeline test PASSED\")\n    true))\n\n;; =============================================================================\n;; Section 4: Run All Tests\n;; =============================================================================\n\n(defn run-phase-4-tests\n  \"Run all Phase 4 tests\"\n  []\n\n  (println \"\\n╔══════════════════════════════════════════════════════════╗\")\n  (println \"║       PHASE 4 TEST SUITE - COMPREHENSIVE VALIDATION     ║\")\n  (println \"╚══════════════════════════════════════════════════════════╝\")\n\n  (let [tests [{:name \"Agent Creation\" :fn test-agent-creation}\n               {:name \"Pattern Recognition\" :fn test-pattern-recognition}\n               {:name \"Pattern Generation\" :fn test-pattern-generation}\n               {:name \"Anomaly Detection\" :fn test-anomaly-detection}\n               {:name \"Multi-Agent Training\" :fn test-agent-training-loop}\n               {:name \"Population Metrics\" :fn test-population-metrics}\n               {:name \"Complete Phase 3→4 Pipeline\" :fn test-complete-phase4-pipeline}]\n\n        results (vec (for [test tests]\n                      (try\n                        ((:fn test))\n                        {:test (:name test) :status :passed}\n                        (catch Exception e\n                          {:test (:name test) :status :failed :error (.getMessage e)}))))]\n\n    ;; Summary\n    (println \"\\n╔══════════════════════════════════════════════════════════╗\")\n    (println \"║              TEST RESULTS SUMMARY                      ║\")\n    (println \"╚══════════════════════════════════════════════════════════╝\\n\")\n\n    (let [passed (count (filter #(= :passed (:status %)) results))\n          failed (count (filter #(= :failed (:status %)) results))]\n\n      (println (str \"Total Tests: \" (count results)))\n      (println (str \"✅ Passed: \" passed))\n      (println (str \"❌ Failed: \" failed))\n      (println \"\")\n\n      (doseq [result results]\n        (if (= :passed (:status result))\n          (printf \"✅ %s\\n\" (:test result))\n          (printf \"❌ %s: %s\\n\" (:test result) (:error result)))))\n\n    (every? #(= :passed (:status %)) results)))\n